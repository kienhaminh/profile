---
description: Require unit tests for every new/changed function and run tests before finishing tasks
alwaysApply: false
---

# Testing Rules (Vitest in `apps/web`)

Follow these rules whenever you add or change a function in `apps/web/src/**`.

## Tooling & Scripts

- Tests are run with Vitest. Use the app-level scripts in [`apps/web/package.json`](mdc:apps/web/package.json):
  - `pnpm --filter @portfolio/web test` for watch/UI
  - `pnpm --filter @portfolio/web test:run` for non-interactive CI/local runs
- At the repo root, `pnpm test` runs tests via Turbo across packages, but prefer the filtered command above for app-only changes.

## Required Workflow

1. When creating or modifying any function in `apps/web/src/**`:
   - Create or update a unit test under `apps/web/tests/unit/**` mirroring the source path and filename, using the suffix `.test.ts` (or `.test.tsx` for React components).
   - Write tests for:
     - Happy path
     - Edge cases and invalid inputs
     - Error handling (specific error types/messages)
2. Before finishing any task that adds or changes a function:
   - Run tests non-interactively and ensure all pass:
     - `pnpm --filter @portfolio/web test:run`
   - Do not mark the task complete until all tests pass.

## Scope & Placement

- Pure logic and utilities (`apps/web/src/lib/**`) → tests in `apps/web/tests/unit/lib/**`.
- Services (`apps/web/src/services/**`) → tests in `apps/web/tests/unit/services/**`.
- API route handlers should delegate logic to services; unit-test the service functions, not the route handlers [[memory:3162015]].

## Style & Quality

- Prefer pure functions; avoid hidden state and side effects in unit tests.
- Strict typing everywhere: no `any`. Use named parameters where applicable.
- Do not hit external systems (DB, network) in unit tests. Mock/stub dependencies.
- Keep tests small, focused, and independent. Avoid shared mutable state between tests.

## Minimal Vitest Template

```ts
import { describe, expect, it, vi } from "vitest";
import { myFunction } from "@/path/to/module";

describe("myFunction", () => {
  it("returns expected result for valid input", () => {
    const result = myFunction({ input: "value" });
    expect(result).toEqual("expected");
  });

  it("throws a specific error for invalid input", () => {
    expect(() => myFunction({ input: "" })).toThrowError(/invalid/i);
  });

  it("handles edge cases deterministically", () => {
    const result = myFunction({ input: "edge" });
    expect(result).toMatchInlineSnapshot();
  });
});
```

## Mocking Example (Services)

```ts
import { describe, expect, it, vi } from "vitest";
import { getProjectById } from "@/services/project";
import * as db from "@/db";

describe("getProjectById", () => {
  it("returns project when found", async () => {
    vi.spyOn(db, "query").mockResolvedValueOnce({
      rows: [{ id: "1", name: "Demo" }],
    });
    const project = await getProjectById({ projectId: "1" });
    expect(project.name).toBe("Demo");
  });
});
```

## File Naming

- Tests: `*.test.ts` or `*.test.tsx`.
- Mirror source directories to keep navigation intuitive.

## Completion Gate

- A task that adds/changes a function is not complete until:
  - A corresponding unit test exists/updated, and
  - `pnpm --filter @portfolio/web test:run` completes successfully with all tests passing.
